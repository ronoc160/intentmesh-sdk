// heatmap.js
let clickMap = {};

function trackClicksForHeatmap(userId, sessionId, apiKey) {
  document.addEventListener("click", (e) => {
    const x = Math.round(e.clientX);
    const y = Math.round(e.clientY);
    const key = `${x},${y}`;
    clickMap[key] = (clickMap[key] || 0) + 1;
  });

  // Flush data every 10 seconds (or when the user leaves)
  setInterval(() => flushClicks$1(userId, sessionId, apiKey), 10000);

  window.addEventListener("beforeunload", () => {
    flushClicks$1(userId, sessionId, apiKey);
  });
}

function flushClicks$1(userId, sessionId, apiKey) {
  const heatmapData = Object.entries(clickMap).map(([position, count]) => {
    const [x, y] = position.split(",").map(Number);
    return { x, y, count };
  });

  if (heatmapData.length === 0) return;

  fetch("http://localhost:3001/api/heatmap", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": apiKey,
    },
    body: JSON.stringify({
      userId,
      sessionId,
      heatmap: heatmapData,
      timestamp: new Date().toISOString(),
    }),
  }).then(() => {
    clickMap = {}; // reset
  });
}

function initHeatmap(userId, sessionId, apiKey) {
  if (!userId || !sessionId || !apiKey) {
    console.warn("❗ Heatmap init missing required params");
    return;
  }
  console.log("🔥 Heatmap tracking enabled");
  trackClicksForHeatmap(userId, sessionId, apiKey);
}

let userIntent = {
  scrollDepth: 0,
  timeOnPage: 0,
  productPricesViewed: [],
  clickedElements: [],
};
let buyerTier = "unknown";
let customTierFn = null;
let intentLevel = "unknown";
let previousIntent = null;
let sdkApiKey = null;
let heatMapClicks = [];
let clickBuffer = [];

let userIdentity = {
  id: null,
  isCustom: false,
};

let intentChangeCallbacks = [];

function onIntentChange(callback) {
  if (typeof callback === "function") {
    intentChangeCallbacks.push(callback);
  }
}

function calculateIntentScore() {
  let score = 0;

  if (userIntent.scrollDepth >= 75) score += 2;
  else if (userIntent.scrollDepth >= 40) score += 1;

  if (userIntent.timeOnPage >= 60) score += 2;
  else if (userIntent.timeOnPage >= 30) score += 1;

  if (userIntent.clickedElements.length >= 3) score += 2;
  else if (userIntent.clickedElements.length >= 1) score += 1;

  intentLevel = score >= 5 ? "high" : score >= 3 ? "medium" : "low";

  if (intentLevel !== previousIntent) {
    const payload = {
      intentLevel,
      buyerTier,
      userIntent,
    };
    intentChangeCallbacks.forEach((cb) => cb(payload));
    previousIntent = intentLevel;
  }

  fetch("http://localhost:3001/api/track", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": sdkApiKey,
    },
    body: JSON.stringify({
      userId: userIdentity.id,
      sessionId: userIntent.sessionId,
      isCustom: userIdentity.isCustom,
      userIntent,
      buyerTier,
      intentLevel,
      timestamp: new Date().toISOString(),
    }),
  })
    .then((res) => res.json())
    .then((data) => console.log("✅ Sent to API:", data))
    .catch((err) => console.error("❌ API error:", err));
}

function trackScrollDepth() {
  window.addEventListener("scroll", () => {
    const scrollTop = window.scrollY;
    const docHeight = document.documentElement.scrollHeight - window.innerHeight;
    const scrollPercent = Math.min(100, Math.round((scrollTop / docHeight) * 100));
    userIntent.scrollDepth = scrollPercent;
  });
}

function trackClickHeatmap() {
  document.addEventListener("click", (e) => {
    const x = e.clientX;
    const y = e.clientY;
    const w = window.innerWidth;
    const h = window.innerHeight;

    heatMapClicks.push({
      xPercent: (x / w).toFixed(3),
      yPercent: (y / h).toFixed(3),
      timestamp: Date.now(),
    });
  });

  setInterval(() => {
    if (heatMapClicks.length === 0 || !userIdentity.id) return;

    const payload = {
      userId: userIdentity.id,
      sessionId: userIntent.sessionId,
      clicks: [...heatMapClicks],
    };

    heatMapClicks = [];

    fetch("http://localhost:3001/api/heatmap", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": sdkApiKey,
      },
      body: JSON.stringify(payload),
    }).then((res) => res.ok && console.log("📍 Heatmap sent"));
  }, 5000);
}

function trackClicks(config = {}) {
  const selectors = config.clickSelectors || ["a", "button"];

  document.addEventListener("click", (e) => {
    const label =
      e.target.closest(selectors.join(","))?.innerText?.trim() ||
      e.target.getAttribute("aria-label")?.trim() ||
      e.target.tagName;

    if (label) userIntent.clickedElements.push(label);

    clickBuffer.push({
      x: e.clientX,
      y: e.clientY,
      timestamp: Date.now(),
      label,
    });

    if (clickBuffer.length >= 20) flushClicks();
  });
}

function flushClicks(useBeacon = false) {
  if (clickBuffer.length === 0) return;

  const payload = {
    userId: userIdentity.id,
    sessionId: userIntent.sessionId,
    clicks: [...clickBuffer],
    timestamp: new Date().toISOString(),
  };

  clickBuffer = [];

  if (useBeacon && navigator.sendBeacon) {
    const blob = new Blob([JSON.stringify(payload)], { type: "application/json" });
    navigator.sendBeacon("http://localhost:3001/api/heatmap", blob);
  } else {
    fetch("http://localhost:3001/api/heatmap", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": sdkApiKey,
      },
      body: JSON.stringify(payload),
    }).catch((err) => console.warn("❌ Heatmap flush error:", err));
  }
}

setInterval(() => flushClicks(false), 5000);
window.addEventListener("beforeunload", () => flushClicks(true));

function trackTimeOnPage() {
  let startTime = Date.now();

  const updateTime = () => {
    const now = Date.now();
    const elapsed = Math.floor((now - startTime) / 1000);
    userIntent.timeOnPage = elapsed;

    if ("requestIdleCallback" in window) {
      requestIdleCallback(updateTime, { timeout: 1000 });
    } else {
      setTimeout(updateTime, 1000);
    }
  };

  updateTime();

  window.addEventListener("beforeunload", () => {
    userIntent.timeOnPage = Math.floor((Date.now() - startTime) / 1000);
    calculateIntentScore();
  });
}

let priceSelectors = [];

function trackPriceView() {
  const priceRegex = /(?:€|\$|£)\s?(\d{1,5}(?:[.,]\d{2})?)/g;
  const prices = new Set();

  function scanPrices() {
    let textToScan = "";

    if (priceSelectors.length > 0) {
      priceSelectors.forEach((selector) => {
        const elements = document.querySelectorAll(selector);
        elements.forEach((el) => {
          textToScan += " " + el.innerText;
        });
      });
    } else {
      textToScan = document.body.innerText;
    }

    let match;
    while ((match = priceRegex.exec(textToScan)) !== null) {
      const raw = match[1].replace(",", ".");
      const value = parseFloat(raw);
      if (!isNaN(value)) prices.add(value);
    }

    userIntent.productPricesViewed = [...prices].sort((a, b) => a - b);

    if (customTierFn) {
      buyerTier = customTierFn([...prices]);
    } else {
      const avg = [...prices].reduce((a, b) => a + b, 0) / prices.size;
      if (avg < 50) buyerTier = "budget";
      else if (avg < 200) buyerTier = "mid";
      else buyerTier = "premium";
    }
  }

  if ("requestIdleCallback" in window) {
    requestIdleCallback(scanPrices);
  } else {
    setTimeout(scanPrices, 1000);
  }
}

function getOrCreateAnonymousId() {
  let id = localStorage.getItem("intentmesh-anon-id");
  if (!id) {
    id = generateUUID();
    localStorage.setItem("intentmesh-anon-id", id);
  }
  return id;
}

function generateUUID() {
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>
    (
      c ^
      (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))
    ).toString(16)
  );
}

function init(config = {}) {
  console.log("✅ IntentMesh SDK initialized");
  sdkApiKey = config.apiKey || null;

  if (config.userId) {
    userIdentity.id = config.userId;
    userIdentity.isCustom = true;
  } else {
    userIdentity.id = getOrCreateAnonymousId();
    userIdentity.isCustom = false;
  }

  userIntent.sessionId = generateUUID();

  if (typeof config.setBuyerTierFromPrices === "function") {
    customTierFn = config.setBuyerTierFromPrices;
  }

  if (config.priceSelectors) {
    priceSelectors = config.priceSelectors;
  }

  trackScrollDepth();
  trackPriceView();
  trackTimeOnPage();
  trackClicks(config);
  trackClickHeatmap();
  initHeatmap?.(userIdentity.id, userIntent.sessionId, sdkApiKey);
}

setInterval(() => {
  calculateIntentScore();
  console.log("Live:", userIntent, buyerTier, intentLevel);
}, 3000);

export { buyerTier, init, intentLevel, onIntentChange, userIntent };
//# sourceMappingURL=intentmesh.min.js.map
